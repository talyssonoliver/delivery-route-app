<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>üß† Ultra Robust Route Generator v3.3 (Fixed)</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    :root{
      --primary:#4299e1;--primary-dark:#3182ce;--secondary:#667eea;--success:#38b2ac;--warning:#f39c12;--error:#e53e3e;
      --gray-50:#f7fafc;--gray-100:#edf2f7;--gray-200:#e2e8f0;--gray-300:#cbd5e0;--gray-600:#718096;--gray-800:#2d3748;--gray-900:#1a202c}
    body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh;padding:20px;line-height:1.6}
    .container{max-width:1000px;margin:0 auto}
    .card{background:#fff;border-radius:16px;padding:24px;margin-bottom:20px;box-shadow:0 10px 30px rgba(0,0,0,.2)}
    h1{font-size:28px;margin-bottom:8px;color:var(--gray-900);font-weight:700}
    h2{font-size:20px;margin-bottom:16px;color:var(--gray-800);font-weight:600}
    h3{font-size:18px;margin-bottom:12px;color:var(--gray-800)}
    .subtitle{color:var(--gray-600);font-size:14px;margin-bottom:16px}
    .version-badge{display:inline-block;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;padding:4px 12px;border-radius:12px;font-size:12px;font-weight:700;margin-left:8px}
    .btn{padding:14px 20px;border:none;border-radius:8px;font-size:16px;font-weight:600;cursor:pointer;transition:all .2s ease;display:inline-flex;align-items:center;justify-content:center;gap:8px}
    .btn:disabled{background:var(--gray-300);cursor:not-allowed;opacity:.6}
    .btn-primary{background:var(--primary);color:#fff}
    .btn-primary:hover:not(:disabled){background:var(--primary-dark);transform:translateY(-1px)}
    .btn-secondary{background:var(--gray-200);color:var(--gray-800)}
    input[type="file"]{width:100%;padding:12px;border:2px dashed var(--gray-300);border-radius:8px;margin-bottom:12px;cursor:pointer;background:var(--gray-50)}
    .checkbox-group{display:flex;align-items:center;gap:8px;margin:12px 0;padding:12px;background:var(--gray-50);border-radius:8px}
    .checkbox-group input[type="checkbox"]{width:18px;height:18px;cursor:pointer}
    .checkbox-group label{font-size:14px;cursor:pointer;user-select:none}
    .alert{padding:14px 16px;border-radius:8px;margin-bottom:16px;font-size:14px;display:flex;align-items:center;gap:8px}
    .alert-warning{background:#fef5e7;border-left:4px solid var(--warning);color:#875a0f}
    .alert-error{background:#fee;border-left:4px solid var(--error);color:#742a2a}
    .alert-success{background:#e6fffa;border-left:4px solid var(--success);color:#234e52}
    .alert-info{background:#ebf8ff;border-left:4px solid var(--primary);color:#2c5282}
    .progress{width:100%;height:10px;background:var(--gray-200);border-radius:5px;overflow:hidden;margin:16px 0}
    .progress-bar{height:100%;background:linear-gradient(90deg,var(--primary) 0%,var(--secondary) 100%);transition:width .3s ease}
    .processing-stage{display:flex;align-items:center;gap:12px;padding:10px 14px;background:var(--gray-50);border-radius:6px;margin-bottom:8px;font-size:13px}
    .processing-stage .icon{width:24px;height:24px;display:flex;align-items:center;justify-content:center;border-radius:50%;font-size:14px}
    .processing-stage.pending .icon{background:var(--gray-300);color:var(--gray-600)}
    .processing-stage.processing .icon{background:var(--primary);color:#fff;animation:pulse 1.5s ease-in-out infinite}
    .processing-stage.complete .icon{background:var(--success);color:#fff}
    .processing-stage.error .icon{background:var(--error);color:#fff}
    @keyframes pulse{0%,100%{opacity:1}50%{opacity:.5}}
    .image-list{max-height:300px;overflow-y:auto;margin-top:12px}
    .image-item{display:flex;justify-content:space-between;align-items:center;padding:10px 14px;background:var(--gray-50);border-radius:6px;margin-bottom:8px;font-size:13px}
    .remove-btn{color:var(--error);cursor:pointer;font-weight:600;padding:4px 8px;border-radius:4px}
    .route-card{border:1px solid var(--gray-200);border-radius:12px;padding:20px;margin-bottom:16px}
    .route-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:16px}
    .badge{background:#ebf8ff;color:#2c5282;padding:6px 14px;border-radius:20px;font-size:13px;font-weight:700}
    .address-list{max-height:300px;overflow-y:auto;background:var(--gray-50);padding:16px;border-radius:8px;font-size:13px;margin-top:12px;display:none}
    .address-item{margin-bottom:12px;padding-bottom:12px;border-bottom:1px solid var(--gray-200)}
    .address-item .stop-num{color:var(--primary);font-weight:700;margin-right:8px}
    .show-addresses{cursor:pointer;color:var(--primary);font-size:14px;margin-top:12px;user-select:none}
    .hidden{display:none!important}
    .debug-panel{background:#1a202c;color:#48bb78;padding:16px;border-radius:8px;font-family:Monaco,monospace;font-size:11px;max-height:300px;overflow-y:auto;margin-top:16px}
    .debug-panel pre{white-space:pre-wrap;word-break:break-all}
    .debug-panel .error{color:#fc8181}
    .debug-panel .warning{color:#f6ad55}
    .debug-panel .info{color:#63b3ed}
    .preview-canvas{max-width:100%;border:1px solid var(--gray-300);border-radius:8px;margin-top:12px}
    .feature-list{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px;margin-top:16px}
    .feature-item{display:flex;align-items:center;gap:8px;padding:10px;background:var(--gray-50);border-radius:6px;font-size:13px}
    .feature-item .icon{font-size:18px}
    .extracted-addresses{background:#f0fdf4;border:1px solid #86efac;border-radius:8px;padding:16px;margin-top:16px}
    .extracted-addresses h4{color:#166534;margin-bottom:12px}
    .address-editor{width:100%;min-height:200px;padding:12px;border:1px solid var(--gray-300);border-radius:6px;font-family:monospace;font-size:13px;margin:12px 0;resize:vertical}
    .stats-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:12px;margin:16px 0}
    .stat-card{background:var(--gray-50);padding:12px;border-radius:8px;text-align:center}
    .stat-value{font-size:24px;font-weight:700;color:var(--primary)}
    .stat-label{font-size:12px;color:var(--gray-600);margin-top:4px}
    .spinner{display:inline-block;width:14px;height:14px;border:2px solid rgba(255,255,255,.3);border-top-color:#fff;border-radius:50%;animation:spin 0.6s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>üß† Ultra Robust Route Generator <span class="version-badge">v3.3 FIXED</span></h1>
      <div class="subtitle">Client-side OCR (Tesseract.js) + multi-layer UK address normalisation with enhanced error handling</div>
      <div class="feature-list">
        <div class="feature-item"><span class="icon">üñºÔ∏è</span><span>Advanced Image Pre-Processing</span></div>
        <div class="feature-item"><span class="icon">üîé</span><span>OCR (Tesseract.js)</span></div>
        <div class="feature-item"><span class="icon">üéØ</span><span>7-Layer Parsing System</span></div>
        <div class="feature-item"><span class="icon">‚úÖ</span><span>UK Postcode Validation</span></div>
      </div>
    </div>

```
<div class="card">
  <h2>üì∏ Upload Run Sheet Images</h2>
  <input type="file" id="imageInput" multiple accept="image/*" />
  <div class="checkbox-group">
    <input type="checkbox" id="enablePreprocessing" checked />
    <label for="enablePreprocessing">
      <strong>Enable Advanced Image Pre-Processing</strong>
      <div style="font-size:12px;color:var(--gray-600);margin-top:4px;">Contrast enhancement, noise reduction, sharpening, OCR optimisation</div>
    </label>
  </div>
  <div class="checkbox-group">
    <input type="checkbox" id="enableManualEdit" checked />
    <label for="enableManualEdit">
      <strong>Allow Manual Address Editing</strong>
      <div style="font-size:12px;color:var(--gray-600);margin-top:4px;">Edit addresses before generating routes</div>
    </label>
  </div>
  <div class="checkbox-group">
    <input type="checkbox" id="enableDebug" checked />
    <label for="enableDebug">
      <strong>Show Debug Information</strong>
      <div style="font-size:12px;color:var(--gray-600);margin-top:4px;">Display all processing stages and OCR logs (recommended for troubleshooting)</div>
    </label>
  </div>

  <div id="imageList" class="image-list"></div>
  <canvas id="previewCanvas" class="preview-canvas hidden"></canvas>
</div>

<div class="card">
  <h2>üìù Manual Address Entry (Skip OCR)</h2>
  <div class="alert alert-info">
    <span>üí°</span>
    <span><strong>OCR not working?</strong> Paste your addresses here (one per line, must include UK postcodes like "123 Street, London, SW1A 1AA GB")</span>
  </div>
  <textarea 
    id="manualAddressInput" 
    class="address-editor" 
    placeholder="Paste addresses here (one per line)...
```

Example:
10 Downing Street, Westminster, London, SW1A 2AA GB
221B Baker Street, Marylebone, London, NW1 6XE GB
Platform 9¬æ, King‚Äôs Cross Station, London, N1 9AP GB‚Äù
style=‚Äúmin-height:150px‚Äù
></textarea>
<button class="btn btn-success" onclick="processManualAddresses()" style="margin-top:12px">
‚úÖ Generate Routes from Manual Input
</button>
</div>

```
<div style="display:flex;gap:10px;margin-bottom:16px">
  <button id="processBtn" class="btn btn-primary" disabled>üß† Process with Ultra Robust AI (7 Layers)</button>
  <button id="cancelBtn" class="btn btn-secondary" disabled>‚úñ Cancel</button>
</div>

<div id="progressSection" class="hidden">
  <div class="card">
    <h2>Processing Pipeline</h2>
    <div id="processingStages"></div>
    <div id="progressText" style="text-align:center;margin:16px 0;font-size:14px;font-weight:500"></div>
    <div class="progress"><div id="progressBar" class="progress-bar" style="width:0%"></div></div>
    <div id="debugPanel" class="debug-panel hidden"></div>
  </div>
</div>

<div id="extractedSection" class="hidden">
  <div class="card">
    <h2>üìç Extracted Addresses</h2>
    <div class="stats-grid">
      <div class="stat-card"><div class="stat-value" id="totalExtracted">0</div><div class="stat-label">Total Extracted</div></div>
      <div class="stat-card"><div class="stat-value" id="validAddresses">0</div><div class="stat-label">Valid Addresses</div></div>
      <div class="stat-card"><div class="stat-value" id="invalidAddresses">0</div><div class="stat-label">Invalid/Skipped</div></div>
    </div>
    <div class="extracted-addresses">
      <h4>Edit addresses below if needed (one per line):</h4>
      <textarea id="addressEditor" class="address-editor"></textarea>
      <div class="btn-group" style="display:flex;gap:10px">
        <button class="btn btn-primary" onclick="generateRoutes()">‚úÖ Generate Routes</button>
        <button class="btn btn-secondary" onclick="reprocessImages()">üîÑ Reprocess Images</button>
      </div>
    </div>
  </div>
</div>

<div id="errorSection" class="hidden">
  <div class="alert alert-error"><span>‚ö†Ô∏è</span><div id="errorText"></div></div>
</div>

<div id="resultsSection" class="hidden">
  <div class="card">
    <h2 id="resultsTitle"></h2>
    <div id="routesList"></div>
  </div>
</div>

<div id="instructionsSection" class="card">
  <h3>‚ú® 7-Layer Ultra Defense System:</h3>
  <div style="margin-top:16px;padding:16px;background:#e6fffa;border-radius:10px;font-size:13px">
    <strong style="font-size:14px">üõ°Ô∏è Processing Layers:</strong>
    <ul style="margin-top:10px;padding-left:20px;line-height:1.8">
      <li><strong>Layer 0:</strong> Advanced Image Pre-Processing (contrast, sharpen, denoise)</li>
      <li><strong>Layer 1:</strong> OCR (Tesseract.js) with timeout + fallback</li>
      <li><strong>Layer 2:</strong> Row parsing with postcode detection</li>
      <li><strong>Layer 3:</strong> Aggressive metadata removal</li>
      <li><strong>Layer 4:</strong> UK Postcode validation & spacing fix</li>
      <li><strong>Layer 5:</strong> Address reconstruction & normalisation</li>
      <li><strong>Layer 6:</strong> Manual editing & verification</li>
    </ul>
  </div>
</div>
```

  </div>

  <!-- Tesseract.js with fallback loading -->

  <script>
    // Try multiple CDNs with fallback
    (function loadTesseractWithFallback() {
      const cdns = [
        'https://cdn.jsdelivr.net/npm/tesseract.js@5.0.5/dist/tesseract.min.js',
        'https://unpkg.com/tesseract.js@v5.0.5/dist/tesseract.min.js',
        'https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/5.0.5/tesseract.min.js'
      ];
      
      let currentIndex = 0;
      
      function tryLoadNext() {
        if (currentIndex >= cdns.length) {
          console.error('‚ùå All CDNs failed to load Tesseract.js');
          window.tesseractLoadFailed = true;
          return;
        }
        
        const script = document.createElement('script');
        script.src = cdns[currentIndex];
        script.async = false;
        
        script.onload = () => {
          console.log(`‚úÖ Loaded Tesseract.js from: ${new URL(cdns[currentIndex]).hostname}`);
          window.tesseractLoadFailed = false;
        };
        
        script.onerror = () => {
          console.warn(`‚ö†Ô∏è Failed to load from: ${cdns[currentIndex]}`);
          currentIndex++;
          tryLoadNext();
        };
        
        document.head.appendChild(script);
      }
      
      tryLoadNext();
    })();
  </script>

  <script>
    'use strict';

    // ===== STATE =====
    let images = [];
    let isProcessing = false;
    let abortProcessing = false;
    let debugMode = true; // Default to true for troubleshooting
    let enablePreprocessing = true;
    let enableManualEdit = true;
    let extractedAddresses = [];
    let tesseractWorker = null;
    let workerInitialized = false;

    // ===== DEBUG UTILITIES =====
    function escapeHtml(s){
      if (typeof s !== 'string') return String(s);
      return s.replace(/[&<>"']/g,(m)=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));
    }

    function debugLog(message, data = null, level = 'info') {
      console.log(`[${level.toUpperCase()}] ${message}`, data || '');
      
      if (!debugMode) return;
      
      const panel = document.getElementById('debugPanel');
      if (!panel) return;
      
      panel.classList.remove('hidden');
      const timestamp = new Date().toLocaleTimeString();
      const levelClass = level === 'error' ? 'error' : level === 'warning' ? 'warning' : 'info';
      
      if (data) {
        const dataStr = typeof data === 'object' ? JSON.stringify(data, null, 2) : String(data);
        panel.innerHTML += `<div class="${levelClass}">[${timestamp}] ${escapeHtml(message)}</div><pre>${escapeHtml(dataStr)}</pre>`;

```
  } else {
    panel.innerHTML += `<div class="${levelClass}">[${timestamp}] ${escapeHtml(message)}</div>`;
  }
  panel.scrollTop = panel.scrollHeight;
}

function updateProcessingStage(stage, status) {
  const stageEl = document.getElementById(`stage-${stage}`);
  if (!stageEl) return;
  stageEl.className = `processing-stage ${status}`;
  const icon = stageEl.querySelector('.icon');
  switch (status) {
    case 'processing': icon.textContent = '‚è≥'; break;
    case 'complete':   icon.textContent = '‚úì';  break;
    case 'error':      icon.textContent = '‚úó';  break;
    default:           icon.textContent = '‚óã';
  }
}

// ===== TIMEOUT UTILITY =====
function withTimeout(promise, ms, label='Operation') {
  let timeoutId;
  const timeoutPromise = new Promise((_, reject) => {
    timeoutId = setTimeout(() => {
      reject(new Error(`${label} timed out after ${ms}ms`));
    }, ms);
  });
  
  return Promise.race([
    promise.finally(() => clearTimeout(timeoutId)),
    timeoutPromise
  ]);
}

// ===== POSTCODES + RULES =====
const UK_POSTCODE_STRICT = /\b(GIR 0AA|[A-Z]{1,2}\d{1,2}[A-Z]?\s?\d[A-Z]{2})\b/i;
const UK_POSTCODE_FINDALL = /\b(GIR 0AA|[A-Z]{1,2}\d{1,2}[A-Z]?\s?\d[A-Z]{2})\b/gi;
const THOROUGHFARES = /\b(Road|Rd|Street|St|Lane|Ln|Avenue|Ave|Drive|Dr|Close|Way|Place|Court|Gardens?|Square|Crescent|Cres|Grove|Park|Hill|View|Mews|Parade|Terrace|Walk|Row)\b/i;
const UNIT_HINTS = /\b(Flat|Apt|Apartment|Unit|Suite|Room|Rm|House|Bldg|Building|Block)\b/i;
const AREAS = /\b(London|Middlesex|Surrey|Kent|Essex|Herts|Hertfordshire|Bucks|Buckinghamshire|Berkshire|Oxfordshire|Bedfordshire|Hillingdon|Harrow|Ealing|Hounslow|Brent|Barnet|Camden|Westminster|Kensington|Chelsea|Islington|Southwark|Lambeth|Wandsworth|Ruislip|Pinner|Northwood|Eastcote|Ickenham|Uxbridge|Hayes|Stanmore)\b/i;
const IGNORE_TOKENS = [
  'Del Weight','Del Items','Deadline','Service Level','Signature','Remarks',
  'Contact Nos','Ref','Name & Time','Security','Tracking','Barcode','Driver',
  'Route','Time Window','Priority','POD','GPS','Manifest','Run','Stop',
  'Delivery','Collection','Col Weight','Col Items'
];

function fixOcrArtifacts(s) {
  return s
    .replace(/[\u2010-\u2015]/g, '-')
    .replace(/[|¬¶]/g, ' ')
    .replace(/\bHAO\b/gi, 'HA0')
    .replace(/\bHAG\b/gi, 'HA6')
    .replace(/\b([A-Z]{1,2}\d{1,2}[A-Z]?)\s*([0O]\w\w)\b/gi, (_, a, b)=>`${a} ${b.replace(/^O/,'0')}`)
    .replace(/\b([A-Z]{1,2})\s+(\d)/g, '$1$2')
    .replace(/\s{2,}/g, ' ')
    .trim();
}

function stripMetadata(line) {
  let s = line;
  for (const kw of IGNORE_TOKENS) {
    const rx = new RegExp(kw.replace(/[-/\\^$*+?.()|[\]{}]/g,'\\$&') + '\\s*[^,|\\n]*','gi');
    s = s.replace(rx,' ');
  }
  s = s.replace(/\b\d{1,2}:\d{2}\b/g,' ');
  s = s.replace(/\b\d{1,2}\/\d{1,2}\/\d{2,4}\b/g,' ');
  s = s.replace(/\+?[\d()\-\s]{10,}/g,' ');
  s = s.replace(/\bRef:?\s*\S+/gi,' ');
  s = s.replace(/^\s*\d{1,3}\s*[.|-]?\s*/,' ');
  s = s.replace(/\b[A-Z]{2,}\d{5,}\b/g,' ');
  s = s.replace(/[|]/g,' ').replace(/\s{2,}/g,' ').replace(/\s*,\s*,+/g, ',').trim();
  return fixOcrArtifacts(s);
}

const NAME_PREFIX = /\b(Mr|Mrs|Ms|Miss|Dr|Prof|Sir|Lady|Lord)\.?\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)?[, ]*/g;
const ALLCAPS_NAME_AT_START = /^[A-Z]{2,}(?:\s+[A-Z]{2,}){0,2}\s*,\s*/;

function removePersonalNames(s) { 
  return s.replace(NAME_PREFIX,'').replace(ALLCAPS_NAME_AT_START,'').trim(); 
}

function normaliseAddressParts(parts) {
  const kept = parts
    .map(p=>p.trim())
    .filter(p => p && (THOROUGHFARES.test(p) || UNIT_HINTS.test(p) || AREAS.test(p) || /\d+[A-Z]?/i.test(p)));
  return Array.from(new Set(kept)).join(', ').replace(/\s*,\s*/g, ', ');
}

function reconstructFromLine(line) {
  const fixed = removePersonalNames(stripMetadata(line));
  const m = fixed.match(UK_POSTCODE_STRICT);
  if (!m) return null;
  const pc = m[1].toUpperCase().replace(/\s?([0-9][A-Z]{2})$/, ' $1');
  const left = fixed.slice(0, m.index).replace(/\b(GB|UK)\b/gi,'').trim();
  const right = fixed.slice(m.index + m[0].length).replace(/\b(GB|UK)\b/gi,'').trim();
  const parts = (left + (right ? ' ' + right : '')).split(/[,|\n]+/).map(s=>s.trim()).filter(Boolean);
  const addr = normaliseAddressParts(parts);
  if (!addr) return null;
  const final = `${addr}, ${pc} GB`.replace(/\s{2,}/g,' ').trim();
  return final.length > 10 ? final : null;
}

function parseOcrToAddresses(text) {
  updateProcessingStage(2, 'processing');
  debugLog('üîç Layer 2: Parsing OCR text to addresses');
  const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const out = [];
  let n = 1;
  for (const raw of lines) {
    if (!UK_POSTCODE_FINDALL.test(raw)) continue;
    const addr = reconstructFromLine(raw);
    if (addr) out.push({ num: n++, address: addr });
  }
  updateProcessingStage(2, out.length ? 'complete' : 'error');
  debugLog(`‚úÖ Layer 2: Extracted ${out.length} potential addresses`);
  return out;
}

function validateAndCleanAddresses(addresses) {
  updateProcessingStage(3, 'processing');
  debugLog(`üîß Layer 3-6: Deep cleaning ${addresses.length} addresses...`);
  const valid = [];
  const invalid = [];
  
  for (const item of addresses) {
    let address = typeof item === 'string' ? item : item.address;
    if (typeof address !== 'string') continue;
    
    address = fixOcrArtifacts(address);
    const pcMatch = address.match(UK_POSTCODE_STRICT);
    
    if (!pcMatch) {
      const recon = reconstructFromLine(address);
      if (recon) address = recon; 
      else { 
        invalid.push(address); 
        debugLog(`‚ùå Invalid (no postcode): ${address}`, null, 'warning');
        continue; 
      }
    }
    
    if (!/\b(GB|UK)\b$/i.test(address)) address += ' GB';
    
    address = address
      .replace(/\b(Deadline|Service Level|Del Weight|Del Items|Ref):[^,]*/gi,'')
      .replace(/\|\s*/g,'')
      .replace(/\s+/g,' ')
      .trim();
    
    if (address.length > 15 && UK_POSTCODE_STRICT.test(address)) {
      valid.push({ num: item.num || (valid.length + 1), address });
      debugLog(`‚úÖ Valid: ${address}`);
    } else {
      invalid.push(address);
      debugLog(`‚ùå Invalid (too short or malformed): ${address}`, null, 'warning');
    }
  }
  
  const seen = new Set(); 
  const dedup = [];
  for (const a of valid) {
    const key = a.address.toUpperCase();
    if (!seen.has(key)) { 
      seen.add(key); 
      dedup.push(a); 
    }
  }
  
  updateProcessingStage(3, 'complete');
  debugLog(`‚úÖ Layer 3-6: ${dedup.length} valid unique addresses, ${invalid.length} invalid`);
  return { valid: dedup, invalid };
}

// ===== IMAGE PRE-PROCESS =====
async function preprocessImage(file) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const reader = new FileReader();
    
    reader.onerror = (err) => {
      debugLog(`‚ùå FileReader error for ${file.name}`, err, 'error');
      reject(new Error(`Failed to read file: ${file.name}`));
    };
    
    reader.onload = (e) => {
      img.onerror = (err) => {
        debugLog(`‚ùå Image load error for ${file.name}`, err, 'error');
        reject(new Error(`Failed to load image: ${file.name}`));
      };
      
      img.onload = () => {
        try {
          const canvas = document.getElementById('previewCanvas');
          if (!canvas) {
            throw new Error('Canvas element not found');
          }
          
          const ctx = canvas.getContext('2d', { willReadFrequently: true });
          if (!ctx) {
            throw new Error('Failed to get canvas context');
          }

          // Reasonable size limits for OCR performance
          const MAX_W = 1400, MAX_H = 2000;
          let w = img.width, h = img.height;
          const r = Math.min(1, MAX_W / w, MAX_H / h);
          canvas.width = Math.round(w * r);
          canvas.height = Math.round(h * r);
          
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

          if (!enablePreprocessing) {
            debugLog(`üì∏ Basic processing only: ${file.name}`);
            canvas.classList.remove('hidden');
            resolve();
            return;
          }

          // Get image data
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;

          debugLog(`üì∏ Advanced pre-processing: ${file.name} (${canvas.width}x${canvas.height})`);

          // 1) Greyscale
          for (let i = 0; i < data.length; i += 4) {
            const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
            data[i] = data[i + 1] = data[i + 2] = gray;
          }
          
          // 2) Contrast enhancement
          const cf = 1.5;
          for (let i = 0; i < data.length; i += 4) {
            const v = Math.min(255, Math.max(0, (data[i] - 128) * cf + 128));
            data[i] = data[i + 1] = data[i + 2] = v;
          }
          
          // 3) Sharpen
          const width = canvas.width, height = canvas.height;
          const kernel = [0,-1,0,-1,5,-1,0,-1,0];
          const out = new Uint8ClampedArray(data);
          
          for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
              let sum = 0;
              for (let ky = -1; ky <= 1; ky++) {
                for (let kx = -1; kx <= 1; kx++) {
                  const idx = ((y + ky) * width + (x + kx)) * 4;
                  const kidx = (ky + 1) * 3 + (kx + 1);
                  sum += data[idx] * kernel[kidx];
                }
              }
              const idx = (y * width + x) * 4;
              out[idx] = out[idx + 1] = out[idx + 2] = Math.min(255, Math.max(0, sum));
            }
          }
          
          // 4) Threshold
          const threshold = 180;
          for (let i = 0; i < out.length; i += 4) {
            const v = out[i] > threshold ? 255 : out[i] < 60 ? 0 : out[i];
            out[i] = out[i + 1] = out[i + 2] = v;
          }
          
          ctx.putImageData(new ImageData(out, width, height), 0, 0);
          canvas.classList.remove('hidden');
          
          debugLog(`‚úÖ Pre-processing complete: ${file.name}`);
          resolve();
        } catch (err) {
          debugLog(`‚ùå Pre-processing error for ${file.name}`, err, 'error');
          reject(err);
        }
      };
      
      img.src = e.target.result;
    };
    
    reader.readAsDataURL(file);
  });
}

// ===== OCR WORKER WITH ROBUST ERROR HANDLING =====
async function initializeOcrWorker() {
  if (workerInitialized && tesseractWorker) {
    debugLog('‚úÖ OCR worker already initialized');
    return tesseractWorker;
  }

  debugLog('üîß Initializing OCR worker...');
  
  try {
    // Check if CDN load failed
    if (window.tesseractLoadFailed) {
      throw new Error(
        'Tesseract.js library failed to load from all CDN sources.\n\n' +
        'üìå Solutions:\n' +
        '1. Check your internet connection\n' +
        '2. Try disabling ad blockers or VPN\n' +
        '3. Download Tesseract.js and host it locally\n' +
        '4. Use the Manual Input option below\n\n' +
        'See the diagnostic tool for more help: route-generator-cdn-fix.html'
      );
    }
    
    // Wait for Tesseract to load if script is still loading
    let attempts = 0;
    while (typeof Tesseract === 'undefined' && attempts < 20) {
      debugLog(`‚è≥ Waiting for Tesseract.js to load... (${attempts + 1}/20)`);
      await new Promise(r => setTimeout(r, 500));
      attempts++;
    }
    
    // Check if Tesseract is loaded
    if (typeof Tesseract === 'undefined') {
      throw new Error(
        'Tesseract.js library not loaded after 10 seconds.\n\n' +
        'üìå This usually means:\n' +
        '1. CDN is blocked by your network/firewall\n' +
        '2. Slow internet connection\n' +
        '3. GitHub Pages CSP restrictions\n\n' +
        'Try the Manual Input option below or see CDN_TIMEOUT_SOLUTION.md for fixes.'
      );
    }

    debugLog('‚úÖ Tesseract.js library loaded');

    // Create worker with LONGER timeout (60s instead of 30s)
    tesseractWorker = await withTimeout(
      Tesseract.createWorker({ 
        logger: (m) => {
          if (debugMode && m.status) {
            const progress = Math.round((m.progress || 0) * 100);
            debugLog(`üß© OCR Worker: ${m.status} ${progress}%`);
          }
        }
      }),
      60000,  // Increased to 60 seconds
      'Worker creation'
    );
    
    debugLog('‚úÖ Worker created, loading language...');
    
    await withTimeout(tesseractWorker.load(), 40000, 'Worker load');  // Increased to 40s
    debugLog('‚úÖ Worker loaded, initializing language...');
    
    await withTimeout(tesseractWorker.loadLanguage('eng'), 40000, 'Language load');  // Increased to 40s
    debugLog('‚úÖ Language loaded, initializing...');
    
    await withTimeout(tesseractWorker.initialize('eng'), 40000, 'Worker initialize');  // Increased to 40s
    debugLog('‚úÖ Worker initialized, setting parameters...');
    
    await withTimeout(
      tesseractWorker.setParameters({
        tessedit_pageseg_mode: Tesseract.PSM.SINGLE_BLOCK,
        tessedit_char_whitelist: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 ,.-:/#()[]|&'\""
      }),
      20000,  // Increased to 20s
      'Set parameters'
    );
    
    workerInitialized = true;
    debugLog('‚úÖ OCR worker fully initialized and ready!');
    return tesseractWorker;
    
  } catch (error) {
    debugLog(`‚ùå OCR worker initialization failed: ${error.message}`, error, 'error');
    
    // Clean up failed worker
    if (tesseractWorker) {
      try {
        await tesseractWorker.terminate();
      } catch (e) {
        debugLog('Failed to terminate worker after error', e, 'warning');
      }
      tesseractWorker = null;
    }
    workerInitialized = false;
    
    throw new Error(
      `Failed to initialize OCR engine: ${error.message}\n\n` +
      'Troubleshooting:\n' +
      '1. Check your internet connection\n' +
      '2. Ensure Tesseract.js CDN is accessible\n' +
      '3. Try refreshing the page\n' +
      '4. Check browser console for detailed errors'
    );
  }
}

async function releaseOcrWorker() {
  if (tesseractWorker) {
    try {
      debugLog('üîß Terminating OCR worker...');
      await withTimeout(tesseractWorker.terminate(), 5000, 'Worker termination');
      debugLog('‚úÖ OCR worker terminated');
    } catch (e) {
      debugLog('‚ö†Ô∏è Error terminating worker', e, 'warning');
    } finally {
      tesseractWorker = null;
      workerInitialized = false;
    }
  }
}

async function recognizeWithTimeout(canvas, msPrimary = 30000, msFallback = 25000) {
  if (!tesseractWorker || !workerInitialized) {
    throw new Error('OCR worker not initialized');
  }

  try {
    debugLog('üß† Starting OCR recognition (primary mode)...');
    await tesseractWorker.setParameters({ 
      tessedit_pageseg_mode: Tesseract.PSM.SINGLE_BLOCK 
    });
    
    const result = await withTimeout(
      tesseractWorker.recognize(canvas), 
      msPrimary, 
      'OCR recognition (primary)'
    );
    
    debugLog('‚úÖ OCR recognition successful (primary mode)');
    return result;
    
  } catch (e) {
    debugLog(`‚ö†Ô∏è Primary OCR failed: ${e.message}. Trying fallback mode...`, null, 'warning');
    
    try {
      await tesseractWorker.setParameters({ 
        tessedit_pageseg_mode: Tesseract.PSM.AUTO 
      });
      
      const result = await withTimeout(
        tesseractWorker.recognize(canvas), 
        msFallback, 
        'OCR recognition (fallback)'
      );
      
      debugLog('‚úÖ OCR recognition successful (fallback mode)');
      return result;
      
    } catch (fallbackError) {
      debugLog(`‚ùå Both OCR modes failed`, fallbackError, 'error');
      throw new Error(`OCR failed: ${fallbackError.message}`);
    }
  }
}

async function processWithOCR(canvas, filename) {
  updateProcessingStage(1, 'processing');
  debugLog(`üß† Layer 1: Starting OCR for ${filename}`);
  
  try {
    const { data } = await recognizeWithTimeout(canvas);
    const text = data.text || '';
    
    updateProcessingStage(1, 'complete');
    debugLog(`‚úÖ Layer 1: OCR complete - ${text.length} characters extracted`);
    
    if (text.length < 10) {
      debugLog('‚ö†Ô∏è OCR extracted very little text', null, 'warning');
    }
    
    return text;
    
  } catch (err) {
    updateProcessingStage(1, 'error');
    debugLog(`‚ùå Layer 1 OCR failed: ${err.message}`, err, 'error');
    throw new Error(`OCR processing failed for ${filename}: ${err.message}`);
  }
}

// ===== MAIN PROCESSING =====
async function processImages() {
  // Validation
  if (images.length === 0) { 
    showError('Please upload at least one image'); 
    return; 
  }

  // Prevent double-processing
  if (isProcessing) {
    debugLog('‚ö†Ô∏è Already processing, ignoring duplicate call', null, 'warning');
    return;
  }

  debugLog('\n='.repeat(50));
  debugLog('üöÄ STARTING NEW PROCESSING SESSION');
  debugLog('='.repeat(50));

  // Initialize state
  abortProcessing = false;
  isProcessing = true;
  enablePreprocessing = document.getElementById('enablePreprocessing').checked;
  enableManualEdit = document.getElementById('enableManualEdit').checked;
  debugMode = document.getElementById('enableDebug').checked;
  
  debugLog(`Configuration: preprocess=${enablePreprocessing}, manualEdit=${enableManualEdit}, debug=${debugMode}`);
  
  updateProcessButton();

  // Reset UI
  document.getElementById('errorSection').classList.add('hidden');
  document.getElementById('resultsSection').classList.add('hidden');
  document.getElementById('extractedSection').classList.add('hidden');
  document.getElementById('instructionsSection').classList.add('hidden');
  document.getElementById('progressSection').classList.remove('hidden');
  document.getElementById('debugPanel').innerHTML = '';

  // Setup stages
  const stagesHtml = `
    <div id="stage-init" class="processing-stage pending"><div class="icon">‚óã</div><div>Initializing OCR Engine</div></div>
    <div id="stage-0" class="processing-stage pending"><div class="icon">‚óã</div><div>Layer 0: Image Pre-Processing</div></div>
    <div id="stage-1" class="processing-stage pending"><div class="icon">‚óã</div><div>Layer 1: OCR Extraction</div></div>
    <div id="stage-2" class="processing-stage pending"><div class="icon">‚óã</div><div>Layer 2: Parse & Reconstruct</div></div>
    <div id="stage-3" class="processing-stage pending"><div class="icon">‚óã</div><div>Layer 3-6: Cleaning & Validation</div></div>`;
  document.getElementById('processingStages').innerHTML = stagesHtml;

  const allAddresses = [];
  const allInvalid = [];
  let failedImages = 0;
  let processedSuccessfully = 0;

  try {
    // Initialize OCR worker first
    updateProcessingStage('init', 'processing');
    document.getElementById('progressText').textContent = 'Initializing OCR engine...';
    
    await initializeOcrWorker();
    updateProcessingStage('init', 'complete');

    if (abortProcessing) {
      debugLog('‚õî Processing cancelled during initialization');
      throw new Error('Processing cancelled by user');
    }

    // Process each image
    for (let i = 0; i < images.length; i++) {
      if (abortProcessing) { 
        debugLog('‚õî Processing cancelled by user'); 
        break; 
      }

      const progress = ((i + 1) / images.length) * 100;
      document.getElementById('progressBar').style.width = progress + '%';
      document.getElementById('progressText').textContent = 
        `Processing image ${i + 1}/${images.length}: ${images[i].name}`;

      debugLog(`\n${'='.repeat(40)}`);
      debugLog(`üì∏ IMAGE ${i + 1}/${images.length}: ${images[i].name}`);
      debugLog(`${'='.repeat(40)}`);

      try {
        // Pre-process image
        if (enablePreprocessing) updateProcessingStage(0, 'processing');
        await preprocessImage(images[i]);
        if (enablePreprocessing) updateProcessingStage(0, 'complete');

        if (abortProcessing) break;

        // Run OCR
        const canvas = document.getElementById('previewCanvas');
        if (!canvas) {
          throw new Error('Canvas element not found');
        }
        
        const ocrText = await processWithOCR(canvas, images[i].name);

        if (abortProcessing) break;

        // Parse addresses
        const parsed = parseOcrToAddresses(ocrText);
        debugLog(`Parsed ${parsed.length} potential addresses from OCR text`);

        // Validate and clean
        const { valid, invalid } = validateAndCleanAddresses(parsed);

        if (valid.length > 0) {
          allAddresses.push(...valid);
          processedSuccessfully++;
          debugLog(`‚úÖ Image ${i + 1}: Extracted ${valid.length} valid addresses`);
        }
        
        if (invalid.length > 0) {
          allInvalid.push(...invalid);
          debugLog(`‚ö†Ô∏è Image ${i + 1}: ${invalid.length} addresses were invalid/skipped`, null, 'warning');
        }
        
        if (valid.length === 0 && parsed.length === 0) {
          failedImages++;
          debugLog(`‚ùå Image ${i + 1}: No addresses found`, null, 'error');
        }

      } catch (imgError) {
        failedImages++;
        debugLog(`‚ùå Image ${i + 1} processing error: ${imgError.message}`, imgError, 'error');
        
        // Continue with next image instead of stopping completely
        showWarning(`Failed to process ${images[i].name}: ${imgError.message}`);
      }

      // Small delay between images to prevent UI freezing
      await new Promise(r => setTimeout(r, 100));
    }

    if (abortProcessing) {
      throw new Error('Processing cancelled by user');
    }

    debugLog('\n' + '='.repeat(50));
    debugLog('üèÅ PROCESSING COMPLETE');
    debugLog('='.repeat(50));

    // Deduplicate and finalize
    const uniqueAddresses = allAddresses
      .filter((addr, index, self) => 
        index === self.findIndex(a => a.address === addr.address))
      .sort((a, b) => a.num - b.num);

    debugLog(`Final results: ${uniqueAddresses.length} unique valid addresses`);
    debugLog(`Total extracted: ${allAddresses.length}, Invalid: ${allInvalid.length}, Failed images: ${failedImages}`);

    // Update stats
    document.getElementById('totalExtracted').textContent = allAddresses.length.toString();
    document.getElementById('validAddresses').textContent = uniqueAddresses.length.toString();
    document.getElementById('invalidAddresses').textContent = allInvalid.length.toString();

    extractedAddresses = uniqueAddresses;

    if (uniqueAddresses.length > 0) {
      document.getElementById('extractedSection').classList.remove('hidden');
      const editor = document.getElementById('addressEditor');
      editor.value = uniqueAddresses.map(a => a.address).join('\n');
      
      if (!enableManualEdit) {
        debugLog('Auto-generating routes (manual edit disabled)');
        generateRoutes();
      } else {
        debugLog('Manual editing enabled - waiting for user to review addresses');
      }
    } else {
      throw new Error(
        `‚ùå No valid addresses extracted from ${images.length} image(s).\n\n` +
        `Results:\n` +
        `‚Ä¢ Successfully processed: ${processedSuccessfully}/${images.length} images\n` +
        `‚Ä¢ Failed images: ${failedImages}\n` +
        `‚Ä¢ Invalid addresses found: ${allInvalid.length}\n\n` +
        `Troubleshooting:\n` +
        `1. Ensure images contain clear UK delivery addresses\n` +
        `2. Check that UK postcodes are visible (e.g., HA6 2WQ, SW1A 1AA)\n` +
        `3. Enable "Advanced Image Pre-Processing" if disabled\n` +
        `4. Review Debug Information above for details\n` +
        `5. Try higher resolution images if text is unclear`
      );
    }

    if (failedImages > 0) {
      showWarning(`‚ö†Ô∏è ${failedImages} out of ${images.length} images failed to process. Check debug log for details.`);
    }

  } catch (err) {
    debugLog(`\n‚ùå‚ùå‚ùå FATAL ERROR ‚ùå‚ùå‚ùå`, err, 'error');
    debugLog(`Error message: ${err.message}`);
    debugLog(`Error stack: ${err.stack}`);
    
    showError(err.message || 'An unexpected error occurred during processing');
    
    // Mark all stages as error
    ['init', 0, 1, 2, 3].forEach(stage => updateProcessingStage(stage, 'error'));
    
  } finally {
    // Cleanup
    try {
      await releaseOcrWorker();
    } catch (e) {
      debugLog('Error during cleanup', e, 'warning');
    }
    
    isProcessing = false;
    abortProcessing = false;
    updateProcessButton();
    
    // Hide progress section after a short delay if we have results
    if (extractedAddresses.length > 0) {
      setTimeout(() => {
        document.getElementById('progressSection').classList.add('hidden');
      }, 1000);
    }
    
    debugLog('\n' + '='.repeat(50));
    debugLog('üèÅ SESSION COMPLETE');
    debugLog('='.repeat(50) + '\n');
  }
}

// ===== ROUTE GENERATION =====
function generateRoutes() {
  debugLog('üìç Generating routes...');
  
  const editor = document.getElementById('addressEditor');
  const addresses = editor.value
    .split('\n')
    .map(a => a.trim())
    .filter(Boolean);

  if (addresses.length === 0) { 
    showError('No addresses available to generate routes'); 
    return; 
  }

  debugLog(`Generating routes for ${addresses.length} addresses`);

  const groups = [];
  const maxStopsPerGroup = 14;

  for (let i = 0; i < addresses.length; i += maxStopsPerGroup) {
    const group = addresses.slice(i, Math.min(i + maxStopsPerGroup, addresses.length));
    const destinations = group.map(addr => encodeURIComponent(addr)).join('&daddr=');
    
    groups.push({
      id: Math.floor(i / maxStopsPerGroup) + 1,
      startStop: i + 1,
      endStop: Math.min(i + maxStopsPerGroup, addresses.length),
      count: group.length,
      stops: group.map((addr, idx) => ({ 
        num: i + idx + 1, 
        address: addr 
      })),
      link: `https://maps.apple.com/?daddr=${destinations}`
    });
  }

  debugLog(`‚úÖ Generated ${groups.length} route(s)`);
  displayResults(groups, addresses.length);
}

function reprocessImages() { 
  debugLog('üîÑ Reprocessing images...');
  processImages(); 
}

// ===== MANUAL ADDRESS PROCESSING (SKIP OCR) =====
function processManualAddresses() {
  debugLog('üìù Processing manual address input');
  
  const textarea = document.getElementById('manualAddressInput');
  const input = textarea.value.trim();
  
  if (!input) {
    showError('Please enter at least one address in the Manual Address Entry box');
    return;
  }

  // Parse addresses from manual input
  const lines = input.split('\n').map(l => l.trim()).filter(Boolean);
  debugLog(`Processing ${lines.length} manual address lines`);

  // Validate and clean addresses
  const { valid, invalid } = validateAndCleanAddresses(
    lines.map((address, i) => ({ num: i + 1, address }))
  );

  if (valid.length === 0) {
    showError(
      `‚ùå No valid UK addresses found in your input.\n\n` +
      `Common issues:\n` +
      `‚Ä¢ Missing UK postcodes (format: SW1A 1AA, NW1 6XE, etc.)\n` +
      `‚Ä¢ Addresses must end with "GB" or "UK"\n` +
      `‚Ä¢ Each address should be on a separate line\n\n` +
      `Example format:\n` +
      `10 Downing Street, Westminster, London, SW1A 2AA GB\n` +
      `221B Baker Street, Marylebone, London, NW1 6XE GB`
    );
    return;
  }

  // Update stats
  document.getElementById('totalExtracted').textContent = lines.length.toString();
  document.getElementById('validAddresses').textContent = valid.length.toString();
  document.getElementById('invalidAddresses').textContent = invalid.length.toString();

  extractedAddresses = valid;

  // Show extracted section with editable addresses
  document.getElementById('extractedSection').classList.remove('hidden');
  document.getElementById('instructionsSection').classList.add('hidden');
  
  const editor = document.getElementById('addressEditor');
  editor.value = valid.map(a => a.address).join('\n');

  // Auto-generate if manual edit is disabled
  if (!enableManualEdit) {
    debugLog('Auto-generating routes (manual edit disabled)');
    generateRoutes();
  }

  // Show success message
  showSuccess(`‚úÖ Processed ${valid.length} valid addresses from manual input!`);
  
  if (invalid.length > 0) {
    showWarning(`‚ö†Ô∏è ${invalid.length} addresses were invalid or skipped (missing UK postcodes)`);
  }

  // Scroll to extracted section
  setTimeout(() => {
    document.getElementById('extractedSection').scrollIntoView({ behavior: 'smooth' });
  }, 100);
}

// ===== UI FUNCTIONS =====
function updateImageList() {
  const listDiv = document.getElementById('imageList');
  const previewCanvas = document.getElementById('previewCanvas');
  
  if (images.length === 0) { 
    listDiv.innerHTML = ''; 
    previewCanvas.classList.add('hidden'); 
    return; 
  }

  const header = document.createElement('div');
  header.style.cssText = 'color: var(--success); font-size: 14px; margin-bottom: 12px; font-weight: 600;';
  header.textContent = `‚úì ${images.length} image(s) selected`;
  
  listDiv.innerHTML = '';
  listDiv.appendChild(header);

  images.forEach((img, idx) => {
    const item = document.createElement('div');
    item.className = 'image-item';
    item.innerHTML = `
      <span style="flex:1;overflow:hidden;text-overflow:ellipsis">${escapeHtml(img.name)}</span>
      <span style="font-size:11px;color:var(--gray-600);margin-right:12px">${formatFileSize(img.size)}</span>
      <button class="remove-btn" onclick="removeImage(${idx})">Remove</button>`;
    listDiv.appendChild(item);
  });
}

function formatFileSize(bytes) { 
  if (bytes < 1024) return bytes + ' B'; 
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB'; 
  return (bytes / (1024 * 1024)).toFixed(1) + ' MB'; 
}

function removeImage(idx) { 
  debugLog(`Removing image: ${images[idx].name}`);
  images.splice(idx, 1); 
  updateImageList(); 
  updateProcessButton(); 
}

function updateProcessButton() {
  const btn = document.getElementById('processBtn');
  const cancel = document.getElementById('cancelBtn');
  
  btn.disabled = !(images.length > 0 && !isProcessing);
  cancel.disabled = !isProcessing;
  
  if (isProcessing) {
    btn.innerHTML = '<span class="spinner"></span> Processing‚Ä¶';
  } else {
    btn.textContent = 'üß† Process with Ultra Robust AI (7 Layers)';
  }
}

function displayResults(groups, totalStops) {
  debugLog('üìä Displaying results');
  
  document.getElementById('resultsTitle').innerHTML = `
    <div style="display:flex;justify-content:space-between;align-items:center">
      <span>‚úì ${totalStops} Deliveries Ready</span>
      <span style="font-size:14px;color:var(--gray-600)">${groups.length} route(s) generated</span>
    </div>`;

  const list = document.getElementById('routesList');
  list.innerHTML = '';

  groups.forEach(g => {
    const card = document.createElement('div');
    card.className = 'route-card';
    card.innerHTML = `
      <div class="route-header">
        <div>
          <div style="font-weight:600;font-size:18px">Route ${g.id}</div>
          <div style="color:var(--gray-600);font-size:13px">Stops ${g.startStop}-${g.endStop}</div>
        </div>
        <div class="badge">${g.count} stops</div>
      </div>
      <a href="${g.link}" target="_blank" class="btn btn-primary" style="text-decoration:none">üó∫Ô∏è Open in Apple Maps</a>
      <button class="btn btn-secondary" onclick="copyLink('${g.link.replace(/'/g, "\\'")}')">üìã Copy Link</button>
      <button class="btn btn-secondary" onclick="copyAddresses(${g.id})">üìÑ Copy All Addresses</button>
      <div class="show-addresses" onclick="toggleAddresses(this)">‚ñº Show ${g.count} addresses</div>
      <div class="address-list" id="addresses-${g.id}">
        ${g.stops.map(s => `
          <div class="address-item">
            <span class="stop-num">${s.num}.</span>${escapeHtml(s.address)}
          </div>
        `).join('')}
      </div>`;
    list.appendChild(card);
  });

  document.getElementById('resultsSection').classList.remove('hidden');
  document.getElementById('extractedSection').classList.add('hidden');
  
  setTimeout(() => {
    document.getElementById('resultsSection').scrollIntoView({ behavior: 'smooth' });
  }, 100);
}

function toggleAddresses(el) {
  const list = el.nextElementSibling;
  if (list.style.display === 'block') { 
    list.style.display = 'none'; 
    el.textContent = el.textContent.replace('‚ñ≤', '‚ñº'); 
  } else { 
    list.style.display = 'block'; 
    el.textContent = el.textContent.replace('‚ñº', '‚ñ≤'); 
  }
}

function copyLink(link) {
  navigator.clipboard.writeText(link)
    .then(() => showSuccess('‚úì Route link copied to clipboard'))
    .catch(() => showError('‚ùå Failed to copy link'));
}

function copyAddresses(groupId) {
  const addressList = document.getElementById(`addresses-${groupId}`);
  const addresses = Array.from(addressList.querySelectorAll('.address-item'))
    .map(item => item.textContent.trim())
    .join('\n');
  
  navigator.clipboard.writeText(addresses)
    .then(() => showSuccess('‚úì All addresses copied to clipboard'))
    .catch(() => showError('‚ùå Failed to copy addresses'));
}

function showError(message) {
  debugLog(`Showing error to user: ${message}`, null, 'error');
  
  const errorSection = document.getElementById('errorSection');
  document.getElementById('errorText').innerHTML = escapeHtml(message).replace(/\n/g, '<br>');
  errorSection.classList.remove('hidden');
  
  setTimeout(() => {
    errorSection.scrollIntoView({ behavior: 'smooth' });
  }, 100);
}

function showSuccess(message) {
  const alert = document.createElement('div');
  alert.className = 'alert alert-success';
  alert.innerHTML = `<span>‚úì</span><span>${escapeHtml(message)}</span>`;
  alert.style.cssText = 'position:fixed;top:20px;right:20px;z-index:9999;min-width:250px;box-shadow:0 4px 12px rgba(0,0,0,0.15)';
  document.body.appendChild(alert);
  
  setTimeout(() => alert.remove(), 3000);
}

function showWarning(message) {
  debugLog(`Warning: ${message}`, null, 'warning');
  
  const alert = document.createElement('div');
  alert.className = 'alert alert-warning';
  alert.innerHTML = `<span>‚ö†Ô∏è</span><span>${escapeHtml(message)}</span>`;
  
  const extractedSection = document.getElementById('extractedSection');
  if (!extractedSection.classList.contains('hidden')) {
    extractedSection.prepend(alert);
  } else {
    alert.style.cssText = 'position:fixed;top:20px;right:20px;z-index:9999;min-width:300px;box-shadow:0 4px 12px rgba(0,0,0,0.15)';
    document.body.appendChild(alert);
    setTimeout(() => alert.remove(), 5000);
  }
}

// ===== GLOBAL ERROR HANDLERS =====
window.addEventListener('error', (e) => {
  debugLog(`‚ùó Uncaught error: ${e.message}`, {
    filename: e.filename,
    lineno: e.lineno,
    colno: e.colno,
    error: e.error
  }, 'error');
  
  if (isProcessing) {
    isProcessing = false;
    abortProcessing = false;
    updateProcessButton();
    showError(`An unexpected error occurred: ${e.message}`);
  }
});

window.addEventListener('unhandledrejection', (e) => {
  debugLog(`‚ùó Unhandled promise rejection: ${e.reason?.message || e.reason}`, {
    reason: e.reason,
    promise: e.promise
  }, 'error');
  
  if (isProcessing) {
    isProcessing = false;
    abortProcessing = false;
    updateProcessButton();
    try { 
      document.getElementById('progressSection').classList.add('hidden'); 
    } catch {}
  }
});

// ===== EVENT LISTENERS =====
document.addEventListener('DOMContentLoaded', () => {
  debugLog('üé¨ Application initialized');

  // File input
  document.getElementById('imageInput').addEventListener('change', (e) => {
    const files = Array.from(e.target.files);
    debugLog(`File input changed: ${files.length} files selected`);
    
    const newImages = files.filter(f => {
      if (!f.type.startsWith('image/')) {
        debugLog(`Rejected ${f.name}: not an image`, null, 'warning');
        return false;
      }
      if (f.size > 10485760) {
        debugLog(`Rejected ${f.name}: too large (${formatFileSize(f.size)})`, null, 'warning');
        return false;
      }
      return true;
    });

    if (newImages.length < files.length) {
      showWarning(`Some files were skipped (must be images under 10MB)`);
    }

    images = newImages;
    debugLog(`Accepted ${images.length} images`);
    
    updateImageList();
    updateProcessButton();
  });

  // Process button
  document.getElementById('processBtn').addEventListener('click', (e) => {
    e.preventDefault(); // Prevent any default behavior
    debugLog('Process button clicked');
    processImages().catch(err => {
      debugLog('Error in processImages', err, 'error');
      showError(`Processing error: ${err.message}`);
    });
  });

  // Cancel button
  document.getElementById('cancelBtn').addEventListener('click', async (e) => {
    e.preventDefault();
    debugLog('Cancel button clicked');
    abortProcessing = true;
    showWarning('Cancelling processing...');
    
    try {
      await releaseOcrWorker();
    } catch (err) {
      debugLog('Error releasing worker during cancel', err, 'warning');
    }
  });

  // Debug toggle
  document.getElementById('enableDebug').addEventListener('change', (e) => {
    debugMode = e.target.checked;
    debugLog(`Debug mode ${debugMode ? 'enabled' : 'disabled'}`);
    
    if (!debugMode) {
      document.getElementById('debugPanel').classList.add('hidden');
    }
  });

  updateProcessButton();
  debugLog('‚úÖ Event listeners attached');
});
```

  </script>
</body>
</html>